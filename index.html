<script type= 'statebus'> # -*- mode: coffee -*-
localStream = null

SMALLEST_PERSON_HEIGHT = 180
SMALLEST_PERSON_WIDTH = 240

old_state = null

janus = null
plugin_handle = null
my_janus_id = null

dom.BODY = ->
  localUser = fetch('ls/localUser')
  if not localUser.name?
    localUser.name = 'Anonymous ' + random_numbers(4)
    save(localUser)

  connections = fetch('/connections')
  if @loading()
    return DIV {}, 'Loading...'
  active_connections = 0
  for conn in connections.all
    if conn.group != null and conn.app == 'talkspace' and conn.space == window.location.pathname.split('/')[1]
      active_connections += 1

  my_conn = fetch('/connection')
  if @loading()
    return DIV {}, 'Loading...'
  me = my_conn.mine
  if not me.id
    me.id = random_string(16)
    me.name = localUser.name
    me.group = (if active_connections == 0 then random_string(16) else null)
    me.timeEntered = (if me.group then Date.now() else -1)
    me.app = 'talkspace'
    me.space = window.location.pathname.split('/')[1]
    me.video = true
    me.audio = true
    save(my_conn)

    if Notification.permission != 'granted'
      # Try to coax user to give us permission to do notifications
      notification 'loaded', 'Welcome to tawk, ' + localUser.name, 'You can change your username at any time'

  state = make_state(connections)

  dimensions = fetch('dimensions')
  recalculate_dimensions = ->
    # One group should first take up the screen horizontally
    # 2-4 groups should take up the screen horizontally
    # Then fallback to min person width/height
    screen_width = window.innerWidth
    screen_height = window.innerHeight - $("#topbar").outerHeight(true)
    if active_connections <= 1
      dimensions.person_height = Math.max(screen_height - 60, SMALLEST_PERSON_HEIGHT)
      dimensions.person_width = Math.max(screen_width / 2 - 60, SMALLEST_PERSON_WIDTH)
    else if active_connections <= 2
      dimensions.person_height = Math.max(screen_height - 60, SMALLEST_PERSON_HEIGHT)
      dimensions.person_width = Math.max(screen_width / 3 - 60, SMALLEST_PERSON_WIDTH)
    else if active_connections <= 4
      dimensions.person_height = Math.max(screen_height / 2 - 60, SMALLEST_PERSON_HEIGHT)
      dimensions.person_width = Math.max(screen_width / 3 - 60, SMALLEST_PERSON_WIDTH)
    else if active_connections <= 7
      dimensions.person_height = Math.max(screen_height / 2 - 60, SMALLEST_PERSON_HEIGHT)
      dimensions.person_width = Math.max(screen_width / 4 - 60, SMALLEST_PERSON_WIDTH)
    else
      dimensions.person_height = SMALLEST_PERSON_HEIGHT
      dimensions.person_width = SMALLEST_PERSON_WIDTH

    if dimensions.person_height > dimensions.person_width * 3 / 4
      dimensions.person_height = dimensions.person_width * 3 / 4
    else if dimensions.person_width = dimensions.person_height * 4 / 3
      dimensions.person_width = dimensions.person_height * 4 / 3
    save(dimensions)

  if not dimensions.person_width? or not JSON.stringify(state) == JSON.stringify(old_state)
    recalculate_dimensions()
  window.onresize = recalculate_dimensions

  # TODO: this is horrible--refactor
  if me.group and old_state
    for groupObj in old_state
      if me.group == groupObj.group and groupObj.members.find((person) -> me.id == person.id)
        my_group = state.find((obj) -> obj.group == me.group)
        for member in my_group.members
          if not groupObj.members.find((person) -> person.id == member.id)
            if not document.hasFocus()
              notification 'tawk_new_member', member.name + ' joined your group', 'Click to say hello'

  old_state = state

  streams = fetch('all_streams')
  if not streams.streams
    streams.streams = {}
    save(streams)

    publish_local_stream = (audio) ->
      plugin_handle.createOffer
        media:
          audioRecv: false
          videoRecv: false
          audioSend: audio
          videoSend: true
        success: (jsep) ->
          plugin_handle.send
            message:
              request: "configure"
              audio: audio
              video: true
            jsep: jsep
        error: (error) ->
          my_conn = fetch('/connection', (my_conn) ->
            if audio
              notification 'no_camera', 'No camera allowed', 'Trying audio-only mode'
              publish_local_stream false
            else
              notification 'no_camera', 'No camera or microphone allowed', 'You are a listener'
          )

    new_remote_feed = (feed) ->
      remote_feed = null
      janus.attach
        plugin: "janus.plugin.videoroom"
        success: (ph) ->
          remote_feed = ph
          remote_feed.send
            message:
              request: "join"
              room: 1234
              ptype: "listener"
              feed: feed.id
        error: console.error
        onmessage: (msg, jsep) ->
          if msg["videoroom"] == "event"
            console.log("TODO: do we care about this event?", msg)
          else if msg["videoroom"] == "slow_link"
            toastr.warning("Slow connection (remote stream " + feed.display + ")", JSON.stringify(msg["videoroom"]))
          else
            console.log("Unhandled event", msg)

          if jsep
            remote_feed.createAnswer
              jsep: jsep
              media:
                audioSend: false
                videoSend: false
              success: (jsep) ->
                remote_feed.send
                  jsep: jsep
                  message:
                    request: "start"
                    room: 1234
              error: console.error
        onlocalstream: Janus.noop
        onremotestream: (stream) ->
          save_streams = (streams) ->
            streams.streams[feed.display] =
              janus_id: my_janus_id
              url: URL.createObjectURL(stream)
              volume: 0
            save streams

            speech = hark(stream, {interval: 200, play: true})
            speech.on('volume_change', (decibals, threshold) ->
              volume_change = (streams) ->
                if decibals < threshold
                  # Probably not human speech
                  decibals = 0
                # Transform to 0-100% scale
                streams.streams[feed.display].volume = -2 * decibals
                save streams
              fetch 'all_streams', volume_change
              forget 'all_streams', volume_change
            )

          fetch 'all_streams', save_streams
          forget 'all_streams', save_streams

        oncleanup: console.error
        detached: console.error

    Janus.init
      callback: ->
        if not Janus.isWebrtcSupported()
          toastr.error "No WebRTC support in your browser. You must use Chrome, Firefox, or Edge"

        janus = new Janus(
          server: 'https://' + window.location.hostname + ':8089/janus'
          success: ->
            janus.attach
              plugin: "janus.plugin.videoroom"
              success: (ph) ->
                plugin_handle = ph
                console.log "Successfully connected to", plugin_handle.getPlugin()
                plugin_handle.send(
                  message:
                    request: "join"
                    room: 1234
                    ptype: "publisher"
                    display: me.id
                )
              error: console.error
              consentDialog: Janus.noop
              onmessage: (msg, jsep) ->
                publishers = msg["publishers"] or []
                for feed in publishers
                  conn = connections.all.find (el) -> el.id == feed.display
                  if not conn
                    toastr.error("ERROR: connection not found", JSON.stringify(feed))
                    continue

                  if not me
                    toastr.error("ERROR: me is undefined", JSON.stringify(me))
                    continue

                  if conn.space == me.space
                    new_remote_feed feed

                if msg["videoroom"] == "joined"
                  my_janus_id = msg["id"]
                  publish_local_stream true
                else if msg["videoroom"] == "destroyed"
                  console.error "Destroyed"
                else if msg["videoroom"] == "event"
                  console.log "TODO: handle detaching streams"
                else if msg["videoroom"] == "error"
                  console.error msg["error"]
                else if msg["videoroom"] == "slow_link"
                  toastr.warning("Slow connection (local stream)", JSON.stringify(msg["videoroom"]["current-bitrate"]))
                else
                  console.error("Unhandled event", msg)

                if jsep
                  plugin_handle.handleRemoteJsep
                    jsep: jsep

              onlocalstream: (stream) ->
                console.log "Got local stream", stream

                save_streams = (streams) ->
                  streams.streams[me.id] =
                    janus_id: my_janus_id
                    url: URL.createObjectURL(stream)
                    volume: 0
                  save streams

                  speech = hark(stream, {interval: 200, play: false})
                  speech.on('volume_change', (decibals, threshold) ->
                    volume_change = (streams) ->
                      if decibals < threshold
                        # Probably not human speech
                        decibals = 0
                      # Transform to 0-100% scale
                      streams.streams[me.id].volume = -2 * decibals
                      save streams
                    fetch 'all_streams', volume_change
                    forget 'all_streams', volume_change
                  )

                fetch 'all_streams', save_streams
                forget 'all_streams', save_streams

              onremotestream: Janus.noop
              oncleanup: console.error
              detached: console.error
          error: console.error
          destroyed: ->
            console.error "Plugin destroyed"
        )

  DIV {},
    TOPBAR
      state: state
      streams: streams
      my_conn: my_conn
      localUser: localUser
    DIV
      style:
        border: '0'
        height: '1px'
        backgroundImage: 'linear-gradient(to right, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.75), rgba(0, 0, 0, 0))'
    GROUPS
      state: state
      streams: streams
      my_conn: my_conn
      localUser: localUser
      dimensions: dimensions

dom.GROUPS = ->
  state = @props.state
  streams = @props.streams
  my_conn = @props.my_conn
  me = my_conn.mine
  localUser = @props.localUser
  drag = fetch 'drag'
  dimensions = @props.dimensions

  DIV
    id: 'groups'
    style:
      height: 'auto'
      minHeight: '85%'
      clear: 'both'
    for groupObj in state
      GROUP
        streams: streams
        group: groupObj.group
        members: groupObj.members
        my_conn: my_conn
        localUser: localUser
        dimensions: dimensions
    if drag.dragging
      GROUP
        streams: streams
        group: drag.ghostGroup
        members: [null]
        my_conn: my_conn
        localUser: localUser
        dimensions: dimensions

dom.GROUP = ->
  streams = @props.streams
  group = @props.group
  members = @props.members
  my_conn = @props.my_conn
  me = my_conn.mine
  localUser = @props.localUser
  dimensions = @props.dimensions

  group_info = fetch('/group/' + group)
  group_editing = fetch('editing-' + group)
  if not group_editing.timer
    group_editing.text = (if group_info.text == undefined then 'This is your group scratch space' else group_info.text)

  divSize = group_size(members.length)

  mouseover_group = fetch('mouseover_group')
  if mouseover_group.group == undefined
    mouseover_group.group = null
    save(mouseover_group)

  if (group == mouseover_group.group and not me.group) or
      (mouseover_group.group == null and group == me.group) or
      (mouseover_group.group == group and group == me.group)
    groupVolume = 1.0
    opacity = 1;
  else if (group == mouseover_group.group)
    groupVolume = 0.8
    opacity = 1;
  else if (group == me.group)
    groupVolume = 0.2
    opacity = 1;
  else if (me.group)
    groupVolume = 0.0
    opacity = 0.5;
  else
    groupVolume = 1.0
    opacity = 0.5;

  DIV
    id: group
    className: 'light-gray'
    style:
      float: 'left'
      margin: '20px'
      height: (divSize.height * dimensions.person_height) + 'px'
      width: (divSize.width * dimensions.person_width) + 'px'
      borderTopLeftRadius: '15px'
      borderTopRightRadius: '15px'
      opacity: opacity

    onMouseEnter: (e) ->
      mouseover_group.group = group
      save(mouseover_group)

    onMouseLeave: (e) ->
      mouseover_group.group = null
      save(mouseover_group)

    for user, index in members
      if user != null
        PERSON
          streams: streams
          person: user
          groupVolume: groupVolume
          my_conn: my_conn
          height: dimensions.person_height
          width: dimensions.person_width
          borders: choose_borders(index, divSize)
    if members[0] != null
      TEXTAREA
        className: 'form-control'
        rows: 2
        style:
          clear: 'both'
          width: '100%'
          backgroundColor: 'inherit'
          borderBottomLeftRadius: '15px'
          borderBottomRightRadius: '15px'
          outline: 'none'
        value: group_editing.text
        onChange: (e) ->
          group_editing.text = e.target.value
          save(group_editing)
          if group_editing.timer
            clearTimeout group_editing.timer
          group_editing.timer = setTimeout ->
            group_editing.timer = null
            save(group_editing)
            group_info.text = group_editing.text
            save(group_info)
          , 500

dom.GROUP.refresh = ->
  streams = @props.streams
  group = @props.group
  members = @props.members
  my_conn = @props.my_conn
  me = my_conn.mine
  localUser = @props.localUser
  dimensions = @props.dimensions

  $(@getDOMNode()).droppable
    tolerance: 'pointer'
    accept: '.person'
    greedy: true
    activeClass: "light-gray"
    hoverClass: "dark-gray"
    drop: ->
      if me.group != group
        me.group = group
        me.timeEntered = Date.now()
        save(my_conn)

dom.PERSON = ->
  streams = @props.streams
  my_conn = @props.my_conn
  me = my_conn.mine
  person = @props.person
  groupVolume = @props.groupVolume
  height = @props.height
  width = @props.width
  borders = @props.borders

  DIV
    title: person.name
    id: person.id
    className: 'person'
    style:
      height: height + 'px'
      width: width + 'px'
      float: 'left'
      position: 'relative'
      cursor: (if person.id == me.id then 'pointer' else '')
    if person.id == me.id
      DIV
        style:
          position: 'absolute'
          width: '100%'
          bottom: '0'
          left: '0'
          zIndex: '100'
          textAlign: 'right'
        BUTTON
          className: 'btn btn-default'
          SPAN
            className: 'glyphicon glyphicon-eye-' + (if me.video then 'open' else 'close')
          onClick: (e) ->
            if me.video
              plugin_handle.muteVideo()
              me.video = false
            else
              plugin_handle.unmuteVideo()
              me.video = true
            save(my_conn)
        BUTTON
          className: 'btn btn-default'
          SPAN
            className: 'glyphicon glyphicon-volume-' + (if me.audio then 'up' else 'off')
          onClick: (e) ->
            if me.audio
              plugin_handle.muteAudio()
              me.audio = false
            else
              plugin_handle.unmuteAudio()
              me.audio = true
            save(my_conn)
    if not person.video
      DIV
        style:
          backgroundColor: 'black'
          height: '100%'
          width: '100%'
          textAlign: 'center'
          fontSize: (height / 180) + 'em'
          textColor: 'white'
          borderTopLeftRadius: (if borders.topLeft then '10px' else '')
          borderTopRightRadius: (if borders.topRight then '10px' else '')
        if person.group != null
          DIV {},
            DIV
              person.name
            BR {},
            DIV
              if person.audio
                '(Audio-Only)'
              else
                '(Muted)'
    else if not streams.streams[person.id]
      DIV
        style:
          height: '100%'
          width: '100%'
          background: 'url(/images/spinner-small.gif) no-repeat center'
    else
      DIV
        style:
          transform: 'scaleX(-1)'
          width: '100%'
          height: height + 'px'
        VIDEO
          autoPlay: 'true'
          src: streams.streams[person.id].url
          style:
            position: 'relative'
            height: '100%'
            width: '100%'
            zIndex: '-1'
            # These properties are flipped horizontally because the div is flipped horizontally
            borderTopLeftRadius: (if borders.topRight then '10px' else '')
            borderTopRightRadius: (if borders.topLeft then '10px' else '')
    if streams.streams[person.id] and person.audio
      DIV
        style:
          position: 'absolute'
          bottom: 0
          right: 0
          height: streams.streams[person.id].volume + 'px'
          width: '20px'
          borderLeft: '5px solid #7FFF00'

dom.PERSON.refresh = ->
  streams = @props.streams
  my_conn = @props.my_conn
  me = my_conn.mine
  person = @props.person
  groupVolume = @props.groupVolume
  drag = fetch 'drag'
  borders = @props.borders

  if person.video and streams.streams[person.id]
    @getDOMNode().getElementsByTagName('video')[0].volume = (if person.id != me.id then groupVolume else 0)

  if me.id == person.id
    $(@getDOMNode()).draggable
      refreshPositions: true
      zIndex: 1000
      start: (e, ui) ->
        drag.dragging = true
        drag.ghostGroup = random_string 16
        save(drag)
      stop: (e, ui) ->
        drag.dragging = false
        drag.ghostGroup = null
        save(drag)

        ui.helper.css
          top: 0
          left: 0

dom.TOPBAR = ->
  state = @props.state
  streams = @props.streams
  my_conn = @props.my_conn
  me = my_conn.mine
  localUser = @props.localUser

  DIV
    id: 'topbar'
    style:
      marginLeft: '35px'
      height: '90px'
    DIV {},
      DIV
        style:
          paddingTop: '20px'
          fontSize: '3vm'
          float: 'right'
          marginRight: '10px'
        ' My name: '
        SPAN
          id: 'username'
          title: 'click to change'
          style:
            cursor: 'pointer'
            fontWeight: 'bold'
          INPUT
            value: localUser.name
            onChange: (e) ->
              localUser.name = e.target.value
              save(localUser)
            onBlur: (e) ->
              me.name = localUser.name
              save(my_conn)
      if me.group == null
        DIV
          style:
            height: '90px'
          DIV {},
            PERSON
              streams: streams
              person: me
              groupVolume: 0
              my_conn: my_conn
              height: 90
              width: 120
              borders: {}
            P
              style:
                float: 'left'
              className: 'triangle-border left'
              'Drag yourself to create or join a group'

dom.TOPBAR.refresh = ->
  state = @props.state
  streams = @props.streams
  my_conn = @props.my_conn
  me = my_conn.mine
  localUser = @props.localUser

  $(@getDOMNode()).droppable
    greedy: true
    tolerance: 'pointer'
    accept: '.person',
    activeClass: "light-gray"
    hoverClass: "dark-gray"
    drop: ->
      me.group = null
      me.timeEntered = -1
      save(my_conn)

alpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
numeric = '0123456789'
alphanumeric = alpha + numeric

random_letters = (num) ->
  _random_string alpha, num
random_numbers = (num) ->
  _random_string numeric, num
random_string = (num) ->
  _random_string alphanumeric, num

_random_string = (string, num) ->
  to_ret = ''
  for i in [0...num]
    to_ret += string[Math.floor(Math.random() * string.length)]
  to_ret

group_size = (num_people) ->
  floor = Math.floor(Math.sqrt(num_people))
  ceil = Math.ceil(Math.sqrt(num_people))

  horizontal_orientation = null
  if floor == ceil
    horizontal_orientation = {height: floor, width: floor}
  else if num_people > floor * ceil
    horizontal_orientation = {height: ceil, width: ceil}
  else
    horizontal_orientation = {height: floor, width: ceil}

  if window.innerWidth > window.innerHeight
    return horizontal_orientation
  else
    return {height: horizontal_orientation.width, width: horizontal_orientation.height}

make_state = (connections) ->
  groups = {}
  for conn in connections.all
    if conn.app == 'talkspace' and
        conn.space == window.location.pathname.split('/')[1] and
        conn.group != null
      if conn.group not of groups
        groups[conn.group] = []
      groups[conn.group].push(conn)
  for el, members of groups
    members.sort (a, b) ->
      return a.timeEntered - b.timeEntered

  # Turn into time-sorted array
  state = ({group: group, members: members} for group, members of groups)
  state.sort (a, b) ->
    # Uses the fact that members lists are already sorted
    return a.members[0].timeEntered - b.members[0].timeEntered

  return state

choose_borders = (index, divSize) ->
  x = index % divSize.width
  y = Math.floor(index / divSize.width)
  borders = {
    topLeft: (x == 0 and y == 0)
    topRight: (x == divSize.width - 1 and y == 0)
  }
  return borders

notification = (tag, title, body) ->
  console.info 'Sending notification', tag, title, body

  create_notification = () ->
    options =
      body: body
      tag: tag
      icon: '/favicon.ico'
    n = new Notification title, options
    setTimeout n.close.bind(n), 5000

    n.addEventListener 'click', () ->
      # Bring them back to tawk
      window.focus()
      n.close()

    # Browsers do not support "sound" property of Notification API
    new Audio('/filling-your-inbox.mp3').play()

  if Notification.permission == 'granted'
    create_notification()
  else if Notification.permission == 'default'
    Notification.requestPermission().then(create_notification)

</script>

<head>
  <meta charset='utf-8'>
  <!-- Always force latest IE rendering engine or request Chrome Frame -->
  <meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'>

  <title>Tawk Space</title>
  <script src='https://code.jquery.com/jquery-2.1.4.min.js'></script>
  <script src='https://code.jquery.com/ui/1.11.4/jquery-ui.min.js'></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui-touch-punch/0.2.3/jquery.ui.touch-punch.min.js"></script>

  <link href='https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css' rel='stylesheet'>
  <link href='https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap-theme.min.css' rel='stylesheet'>
  <script src='https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js'></script>

  <script src='https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/js/toastr.min.js'></script>
  <link href='https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/css/toastr.min.css' rel='stylesheet'>

  <script src='/node_modules/hark/hark.bundle.js'></script>

  <style>
    html, body { background-color: #F7F7F7 }
    .light-gray { background-color: #D9D9D9 }
    .dark-gray { background-color: #BFBFBF }
  </style>
  <link href='/triangle.css' rel='stylesheet'>
</head>

<script>
  statebus_server = window.location.protocol + '//' + window.location.hostname + ':3003'
  statebus_version = 3
</script>
<script src="https://stateb.us/client.js" ></script>
<script src="/janus.js" ></script>
