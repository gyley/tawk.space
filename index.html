<script type= 'statebus'> # -*- mode: coffee -*-
plugin_handle = null

###############################################################################
# Client Bus
###############################################################################

bus('connections').to_fetch = (key) ->
  connections = fetch '/connections'
  if not connections.all
    connections.all = []

  connections

bus('connection/*').to_fetch = (key) ->
  connections = fetch 'connections'
  target_id = key.split('/')[1]
  conn = connections.all.find (el) -> el.id == target_id

  conn or {id: target_id}

bus('_groups').to_fetch = (key) ->
  groups = {}
  connections = fetch 'connections'
  for conn in connections.all
    if conn.app == 'talkspace' and
        conn.space == window.location.pathname.split('/')[1] and
        conn.group != null

      if conn.group not of groups
        groups[conn.group] = []
      groups[conn.group].push(conn)

  for gid, members of groups
    members.sort (a, b) ->
      return a.timeEntered - b.timeEntered

  groups: groups

bus('group/*').to_fetch = (key) ->
  groups = fetch('_groups').groups or {}
  gid = key.split('/')[1]

  members: (groups[gid] or [])

bus('gids').to_fetch = (key) ->
  groups = fetch('_groups').groups or {}
  gids = (gid for gid, members of groups)
  gids.sort (gidA, gidB) ->
    # Uses the fact that members lists are already sorted
    return groups[gidA][0].timeEntered - groups[gidB][0].timeEntered

  ids: gids

bus('active_connections').to_fetch = (key) ->
  connections = fetch 'connections'

  count = 0
  for conn in connections.all
    if conn.app == 'talkspace' and conn.space == window.location.pathname.split('/')[1]
      count += 1

  count: count

bus('dimensions').to_fetch = (key) ->
  connections = fetch '/connections'
  active_connections = fetch 'active_connections'

  screen_width = fetch('window_size').width
  screen_height = fetch('window_size').height

  # 240 x 180 is the minimum
  person_height = 180
  person_width = 240

  # Hacky way to render groups as big as possible
  # when there are only a few people in the space
  if active_connections.count <= 1
    person_height = Math.max(screen_height - 60, person_height)
    person_width = Math.max(screen_width / 2 - 60, person_width)
  else if active_connections.count <= 2
    person_height = Math.max(screen_height - 60, person_height)
    person_width = Math.max(screen_width / 3 - 60, person_width)
  else if active_connections.count <= 4
    person_height = Math.max(screen_height / 2 - 60, person_height)
    person_width = Math.max(screen_width / 3 - 60, person_width)
  else if active_connections.count <= 7
    person_height = Math.max(screen_height / 2 - 60, person_height)
    person_width = Math.max(screen_width / 4 - 60, person_width)

  if person_height > person_width * 3 / 4
    person_height = person_width * 3 / 4
  else if person_width > person_height * 4 / 3
    person_width = person_height * 4 / 3

  person_height: person_height
  person_width: person_width

bus('window_size').to_fetch = (key) ->
  width: window.innerWidth
  height: window.innerHeight - $("#topbar").outerHeight(true)

window.onresize = () ->
  bus.dirty 'window_size'

###############################################################################
# React render functions
###############################################################################

dom.BODY = ->
  localUser = fetch('ls/localUser')
  if not localUser.name
    localUser.name = 'Anonymous ' + random_numbers(4)
    save(localUser)

  connections = fetch('/connections')
  if @loading()
    return DIV {}, 'Loading...'

  active_connections = fetch('active_connections')

  me = fetch('/connection')
  if @loading()
    return DIV {}, 'Loading...'
  if not me.id
    me.id = random_string(16)
    me.name = localUser.name
    me.group = fetch('gids').ids[0] or random_string(16)
    me.timeEntered = me.group
    me.app = 'talkspace'
    me.space = window.location.pathname.split('/')[1]
    me.video = true
    me.audio = true
    save(me)

  initialize_janus(me.id, me.space)

  DIV {},
    TOPBAR()
    DIV
      style:
        border: '0'
        height: '1px'
        backgroundImage: 'linear-gradient(to right, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.75), rgba(0, 0, 0, 0))'
    GROUPS()

dom.GROUPS = ->
  gids = fetch('gids').ids or []
  drag = fetch 'drag'

  DIV
    id: 'groups'
    style:
      height: 'auto'
      minHeight: '85%'
      clear: 'both'
    for gid in gids
      GROUP
        gid: gid
    if drag.dragging
      GROUP
        gid: drag.ghostGroup

dom.GROUP = ->
  gid = @props.gid
  members = fetch('group/' + gid).members or []
  dimensions = fetch 'dimensions'
  drag = fetch 'drag'

  group_info = fetch('/group/' + gid)
  group_editing = fetch('editing-' + gid)
  if not group_editing.timer
    group_editing.text = (if group_info.text == undefined then 'This is your group scratch space' else group_info.text)

  divSize = group_size(members.length or 1) # ghost group is size 1

  me = fetch '/connection'

  DIV
    id: gid
    className: (if drag.over == gid then 'dark-gray' else 'light-gray')
    style:
      float: 'left'
      margin: '20px'
      height: (divSize.height * dimensions.person_height) + 'px'
      width: (divSize.width * dimensions.person_width) + 'px'
      borderTopLeftRadius: '15px'
      borderTopRightRadius: '15px'

    onMouseEnter: (e) ->
      me.mouseover = gid
      save(me)

    onMouseLeave: (e) ->
      me.mouseover = null
      save(me)

    for user, index in members
      if user != null
        PERSON
          person: user
          height: dimensions.person_height
          width: dimensions.person_width
          borders: choose_borders(index, divSize)
    if members.length
      AUTOSIZEBOX
        className: 'form-control'
        rows: 2
        style:
          clear: 'both'
          width: '100%'
          backgroundColor: 'inherit'
          borderBottomLeftRadius: '15px'
          borderBottomRightRadius: '15px'
          outline: 'none'
          border: '1px solid #aaa'
        value: group_editing.text
        onChange: (e) ->
          group_editing.text = e.target.value
          save(group_editing)
          if group_editing.timer
            clearTimeout group_editing.timer
          group_editing.timer = setTimeout ->
            group_editing.timer = null
            save(group_editing)
            group_info.text = group_editing.text
            save(group_info)
          , 500

dom.GROUP.refresh = ->
  gid = @props.gid

  me = fetch '/connection'

  $(@getDOMNode()).droppable
    tolerance: 'pointer'
    accept: '.person'
    greedy: true
    over: ->
      drag = fetch 'drag'
      drag.over = gid
      save(drag)
    out: ->
      drag = fetch 'drag'
      if drag.over == gid
        # If not, another over event has fired on another group
        # and we do not want to clear the group
        drag.over = null
        save(drag)
    drop: ->
      if me.group != gid
        me.group = gid
        me.timeEntered = Date.now()
        save(me)

dom.PERSON = ->
  person = @props.person
  height = @props.height
  width = @props.width
  borders = @props.borders
  stream = fetch 'stream/' + person.id
  me = fetch '/connection'

  DIV
    title: person.name
    id: person.id
    className: 'person'
    style:
      height: height + 'px'
      width: width + 'px'
      float: 'left'
      position: 'relative'
      cursor: (if person.id == me.id then 'pointer' else '')
      opacity: (if should_hear_fully(person, me) then 1.0 else 0.5)
    if person.id == me.id
      DIV
        style:
          position: 'absolute'
          width: '100%'
          bottom: '0'
          left: '0'
          zIndex: '100'
          textAlign: 'right'
        BUTTON
          className: 'btn btn-default'
          SPAN
            className: 'glyphicon glyphicon-eye-' + (if me.video then 'open' else 'close')
          onClick: (e) ->
            if me.video
              plugin_handle.muteVideo()
              me.video = false
            else
              plugin_handle.unmuteVideo()
              me.video = true
            save(me)
        BUTTON
          className: 'btn btn-default'
          SPAN
            className: 'glyphicon glyphicon-volume-' + (if me.audio then 'up' else 'off')
          onClick: (e) ->
            if me.audio
              plugin_handle.muteAudio()
              me.audio = false
            else
              plugin_handle.unmuteAudio()
              me.audio = true
            save(me)
    if person.video
      transform = 'scaleX(-1)'
      if fetch('connection/' + person.id).flip_y
        transform += ' scaleY(-1)'
      DIV
        style:
          transform: transform
          width: '100%'
          height: height + 'px'
        onDoubleClick: => me.flip_y = not me.flip_y; save(me)
        VIDEO
          autoPlay: 'true'
          src: stream.url
          style:
            position: 'relative'
            height: '100%'
            width: '100%'
            zIndex: '-1'
            # These properties are flipped horizontally because the div is flipped horizontally
            borderTopLeftRadius: (if borders.topRight then '10px' else '')
            borderTopRightRadius: (if borders.topLeft then '10px' else '')
    else
      DIV
        style:
          backgroundColor: 'black'
          height: '100%'
          width: '100%'
          textAlign: 'center'
          fontSize: (height / 180) + 'em'
          textColor: 'white'
          borderTopLeftRadius: (if borders.topLeft then '10px' else '')
          borderTopRightRadius: (if borders.topRight then '10px' else '')
        DIV {},
          DIV
            person.name
          BR {},
          DIV
            if person.audio
              '(Audio-Only)'
            else
              '(Muted)'
    if person.audio
      DIV
        style:
          position: 'absolute'
          bottom: 0
          right: 0
          height: stream.volume + 'px'
          width: '20px'
          borderLeft: '5px solid #7FFF00'
        AUDIO
          autoPlay: 'true'
          src: stream.url

dom.PERSON.refresh = ->
  person = @props.person
  borders = @props.borders
  drag = fetch 'drag'
  stream = fetch 'stream/' + person.id
  me = fetch '/connection'

  volume = 0
  if person.id != me.id
    if should_hear_fully(person, me)
      volume = 1.0
    else
      volume = 0.04
  vids = @getDOMNode().getElementsByTagName('video')
  if vids.length
    vids[0].volume = 0
  auds = @getDOMNode().getElementsByTagName('audio')
  if auds.length
    auds[0].volume = volume

  if me.id == person.id
    $(@getDOMNode()).draggable
      refreshPositions: true
      zIndex: 1000
      start: (e, ui) ->
        drag.over = null
        drag.dragging = true
        drag.ghostGroup = random_string 16
        save(drag)
      stop: (e, ui) ->
        drag.over = null
        drag.dragging = false
        drag.ghostGroup = null
        save(drag)

        ui.helper.css
          top: 0
          left: 0

dom.TOPBAR = ->
  state = @props.state
  localUser = fetch 'ls/localUser'
  me = fetch '/connection'

  DIV
    id: 'topbar'
    style:
      marginLeft: '35px'
    DIV {},
      DIV
        style:
          paddingTop: '20px'
          fontSize: '3vm'
          float: 'right'
          marginRight: '10px'
        ' My name: '
        SPAN
          id: 'username'
          title: 'click to change'
          style:
            cursor: 'pointer'
            fontWeight: 'bold'
          INPUT
            value: localUser.name
            onChange: (e) ->
              localUser.name = e.target.value
              save(localUser)
            onBlur: (e) ->
              me.name = localUser.name
              save(me)

dom.AUTOSIZEBOX = ->
  TEXTAREA
    ref: 'textbox'
    rows: 1
    placeholder: @props.placeholder
    onKeyDown: (e) =>@props.onKeyDown?(e)
    onChange: (e) => @props.onChange?(e)
    style: @props.style
    value: @props.value

resizebox = (target) ->
  while(target.rows > 1 && target.scrollHeight < target.offsetHeight)
    target.rows--
  while(target.scrollHeight > target.offsetHeight)
    target.rows++
dom.AUTOSIZEBOX.up      = -> resizebox(@refs.textbox.getDOMNode())
dom.AUTOSIZEBOX.refresh = -> resizebox(@refs.textbox.getDOMNode())

alpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
numeric = '0123456789'
alphanumeric = alpha + numeric

random_letters = (num) ->
  _random_string alpha, num
random_numbers = (num) ->
  _random_string numeric, num
random_string = (num) ->
  _random_string alphanumeric, num

_random_string = (string, num) ->
  to_ret = ''
  for i in [0...num]
    to_ret += string[Math.floor(Math.random() * string.length)]
  to_ret

should_hear_fully = (person, me) ->
  me.group in [person.group, person.mouseover] or
    (me.mouseover in [person.group, person.mouseover] and me.mouseover != null)

group_size = (num_people) ->
  floor = Math.floor(Math.sqrt(num_people))
  ceil = Math.ceil(Math.sqrt(num_people))

  horizontal_orientation = null
  if floor == ceil
    horizontal_orientation = {height: floor, width: floor}
  else if num_people > floor * ceil
    horizontal_orientation = {height: ceil, width: ceil}
  else
    horizontal_orientation = {height: floor, width: ceil}

  if window.innerWidth > window.innerHeight
    return horizontal_orientation
  else
    return {height: horizontal_orientation.width, width: horizontal_orientation.height}

choose_borders = (index, divSize) ->
  x = index % divSize.width
  y = Math.floor(index / divSize.width)
  borders = {
    topLeft: (x == 0 and y == 0)
    topRight: (x == divSize.width - 1 and y == 0)
  }
  return borders

###############################################################################
# Send and receive video streams
###############################################################################

publish_local_stream = (audio) ->
  plugin_handle.createOffer
    media:
      audioRecv: false
      videoRecv: false
      audioSend: audio
      videoSend: true
    success: (jsep) ->
      plugin_handle.send
        message:
          request: "configure"
          audio: audio
          video: true
        jsep: jsep
    error: (error) ->
      if audio
        console.error 'no_camera', 'No camera allowed', 'Trying audio-only mode'
        publish_local_stream false
      else
        console.error 'no_camera', 'No camera or microphone allowed', 'You are a listener'

new_remote_feed = (janus, feed) ->
  remote_feed = null
  {id, space} = JSON.parse feed.display
  janus.attach
    plugin: "janus.plugin.videoroom"
    success: (ph) ->
      remote_feed = ph
      remote_feed.send
        message:
          request: "join"
          room: 1234
          ptype: "listener"
          feed: feed.id
    error: console.error
    onmessage: (msg, jsep) ->
      if msg["videoroom"] == "event"
        console.log("TODO: do we care about this event?", msg)
      else if msg["videoroom"] == "slow_link"
        console.log('slow link', "Slow connection (remote stream " + id + ")", JSON.stringify(msg["videoroom"]))
      else
        console.log("Unhandled event", msg)

      if jsep
        remote_feed.createAnswer
          jsep: jsep
          media:
            audioSend: false
            videoSend: false
          success: (jsep) ->
            remote_feed.send
              jsep: jsep
              message:
                request: "start"
                room: 1234
          error: console.error
    onlocalstream: Janus.noop
    onremotestream: (stream) ->
      # TODO: forget this key when they leave
      save
        key: 'stream/' + id,
        url: URL.createObjectURL(stream)
        volume: 0

      speech = hark(stream, {interval: 200, play: false})
      speech.on('volume_change', (decibals, threshold) ->
        stream = fetch 'stream/' + id
        if decibals < threshold
          # Probably not human speech
          decibals = 0
        # Transform to 0-100% scale
        stream.volume = -2 * decibals
        save stream
      )

    oncleanup: console.error
    detached: console.error

initialize_janus = (my_id, my_space) ->
  if fetch('janus').initialized
    return
  save
    key: 'janus'
    initialized: true

  Janus.init
    callback: ->
      if not Janus.isWebrtcSupported()
        console.error '', "No WebRTC support in your browser.", "You must use Chrome, Firefox, or Edge"

      janus = new Janus(
        server: 'https://' + window.location.hostname + ':8089/janus'
        success: ->
          janus.attach
            plugin: "janus.plugin.videoroom"
            success: (ph) ->
              plugin_handle = ph
              console.log "Successfully connected to", plugin_handle.getPlugin()
              plugin_handle.send(
                message:
                  request: "join"
                  room: 1234
                  ptype: "publisher"
                  display: JSON.stringify
                    id: my_id
                    space: my_space
              )
            error: console.error
            consentDialog: Janus.noop
            onmessage: (msg, jsep) ->
              publishers = msg["publishers"] or []
              for feed in publishers
                {id, space} = JSON.parse feed.display
                if space == my_space
                  new_remote_feed janus, feed

              if msg["videoroom"] == "joined"
                publish_local_stream true
              else if msg["videoroom"] == "destroyed"
                console.error "Destroyed"
              else if msg["videoroom"] == "event"
                console.log "TODO: handle detaching streams"
              else if msg["videoroom"] == "error"
                console.error msg["error"]
              else if msg["videoroom"] == "slow_link"
                console.log 'slow link', "Slow connection (local stream)", JSON.stringify(msg["videoroom"]["current-bitrate"])
              else
                console.log("Unhandled event", msg)

              if jsep
                plugin_handle.handleRemoteJsep
                  jsep: jsep

            onlocalstream: (stream) ->
              console.log "Got local stream", stream

              save
                key: 'stream/' + my_id
                url: URL.createObjectURL(stream)
                volume: 0

              speech = hark(stream, {interval: 200, play: false})
              speech.on('volume_change', (decibals, threshold) ->
                stream = fetch 'stream/' + my_id
                if decibals < threshold
                  # Probably not human speech
                  decibals = 0
                # Transform to 0-100% scale
                stream.volume = -2 * decibals
                save stream
              )

            onremotestream: Janus.noop
            oncleanup: console.error
            detached: console.error
        error: console.error
        destroyed: ->
          console.error "Plugin destroyed"
      )

</script>

<head>
  <meta charset='utf-8'>
  <meta content='Social video chats. Tawk is simple and flexible -- there is no login, and each space can have multiple chat groups.' name="description">

  <title>Tawk Space</title>
  <script src='https://code.jquery.com/jquery-2.1.4.min.js'></script>
  <script src='https://code.jquery.com/ui/1.11.4/jquery-ui.min.js'></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui-touch-punch/0.2.3/jquery.ui.touch-punch.min.js"></script>

  <link href='https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css' rel='stylesheet'>
  <link href='https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap-theme.min.css' rel='stylesheet'>
  <script src='https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js'></script>

  <script src='/node_modules/hark/hark.bundle.js'></script>

  <style>
    html, body { background-color: #F7F7F7 }
    .light-gray { background-color: #D9D9D9 }
    .dark-gray { background-color: #BFBFBF }
  </style>
</head>

<script>
  statebus_server = window.location.protocol + '//' + window.location.hostname + ':3004'
  statebus_version = 4
</script>
<script src="https://stateb.us/client4.js" ></script>
<script src="/janus.js" ></script>
